Object subclass: #SLAabtractTile	instanceVariableNames: 'position'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLAabtractTile commentStamp: 'ab 11/8/2018 22:07' prior: 0!Aabtract Tile Class!!SLAabtractTile methodsFor: 'visiting' stamp: 'ab 12/14/2018 20:54'!acceptPlayer: aPlayer	aPlayer position: position! !!SLAabtractTile methodsFor: 'accessing' stamp: 'ab 11/8/2018 22:09'!position	^ position! !!SLAabtractTile methodsFor: 'accessing' stamp: 'ab 11/8/2018 22:09'!position: anInteger	position := anInteger! !!SLAabtractTile methodsFor: 'as yet unclassified' stamp: 'ab 12/14/2018 20:56'!releasePlayer: aPlayer	"Do nothing by default, subclasses may modify this behavior."! !!SLAabtractTile methodsFor: 'printing' stamp: 'ab 11/28/2018 22:07'!printOn: aStream	aStream << '['.	self printInsideOn: aStream.	aStream << ']'! !!SLAabtractTile methodsFor: 'printing' stamp: 'ab 11/28/2018 22:06'!printInsideOn: aStream	position printOn: aStream! !SLAabtractTile subclass: #SLActiveTile	instanceVariableNames: 'targetTile'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLActiveTile commentStamp: 'ab 11/8/2018 22:12' prior: 0!Active Tile Class!!SLActiveTile methodsFor: 'accessing' stamp: 'ab 11/8/2018 22:13'!to: aTile	targetTile := aTile! !!SLActiveTile methodsFor: 'visiting' stamp: 'ab 12/15/2018 23:38'!acceptPlayer: aPlayer	targetTile acceptPlayer: aPlayer! !Object subclass: #SLGame	instanceVariableNames: 'tiles players turn'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLGame commentStamp: 'ab 10/23/2018 22:07' prior: 0!SLGame Class!!SLGame methodsFor: 'accessing' stamp: 'ab 10/27/2018 21:06'!tileAt: aNumber	^ tiles at: aNumber! !!SLGame methodsFor: 'accessing' stamp: 'ab 12/15/2018 23:56'!turn: aNumber	turn := aNumber! !!SLGame methodsFor: 'adding' stamp: 'ab 12/15/2018 23:58'!addPlayer: aPlayer	aPlayer position: 1.	(tiles at: 1) addPlayer: aPlayer.	players add: aPlayer! !!SLGame methodsFor: 'as yet unclassified' stamp: 'ab 10/23/2018 22:17'!tileNumber	^ tiles size! !!SLGame methodsFor: 'as yet unclassified' stamp: 'ab 12/16/2018 21:20'!currentPlayer	| rest playerIndex |	rest := (turn \\ players size).	playerIndex := (rest isZero		ifTrue:[players size]		ifFalse:[rest]).	^ players at: playerIndex! !!SLGame methodsFor: 'as yet unclassified' stamp: 'ab 11/3/2018 22:12'!tileOfPlayer: aPlayer	^ tiles at: aPlayer position! !!SLGame methodsFor: 'as yet unclassified' stamp: 'ab 11/3/2018 22:09'!tileFor: aPlayer atDistance: aNumber	^ tiles at: (aPlayer position) + aNumber! !!SLGame methodsFor: 'as yet unclassified' stamp: 'ab 12/18/2018 21:13'!playOneStepWithRoll: aNumber	| currentPlayer |	turn := turn + 1.	currentPlayer := self currentPlayer.	Transcript show: currentPlayer printString, 'drew ', aNumber printString, ': '.	(self canMoveToPosition: currentPlayer position + aNumber)		ifTrue: [ self movePlayer: currentPlayer distance: aNumber ].		Transcript show: self; cr! !!SLGame methodsFor: 'as yet unclassified' stamp: 'ab 12/20/2018 14:31'!movePlayer: aPlayer distance: anInteger	| newtile |	(self tileOfPlayer: aPlayer) releasePlayer: aPlayer.	newtile := self tileFor: aPlayer atDistance: anInteger.	newtile acceptPlayer: aPlayer! !!SLGame methodsFor: 'as yet unclassified' stamp: 'ab 10/23/2018 22:17'!tileNumber: aNumber	| counter |	counter := 1.	tiles := Array new: aNumber.	aNumber timesRepeat:[		tiles at:counter put: (SLTile new position: counter).		counter := counter + 1		]! !!SLGame methodsFor: 'testing' stamp: 'ab 12/16/2018 21:34'!isOver	^ players anySatisfy: [ :player | player position = tiles size ]! !!SLGame methodsFor: 'testing' stamp: 'ab 12/18/2018 21:05'!canMoveToPosition: aNumber	^ aNumber <= self tileNumber! !!SLGame methodsFor: 'playing' stamp: 'ab 12/20/2018 14:15'!play	Transcript show: self; cr.	[ self isOver not ] whileTrue: [ 	self playOneStepWithRoll: 6 atRandom	 ]! !!SLGame methodsFor: 'printing' stamp: 'ab 10/23/2018 22:14'!printOn: aStream	tiles do: [ :aTile |		aTile printOn: aStream		 ]! !!SLGame methodsFor: 'initialization' stamp: 'ab 12/15/2018 23:49'!initialize	turn := 0.	players := OrderedCollection new! !!SLGame methodsFor: 'initialization' stamp: 'ab 11/29/2018 22:03'!setSnakeFrom: aSourcePosition to: aTargetPosition	tiles at: aSourcePosition put:		(SLSnakeTile new position: aSourcePosition; to: (self tileAt: aTargetPosition))! !!SLGame methodsFor: 'initialization' stamp: 'ab 11/29/2018 22:03'!setLadderFrom: aSourcePosition to: aTargetPosition	tiles at: aSourcePosition put:		(SLLadderTile new position: aSourcePosition; to: (self tileAt: aTargetPosition))! !TestCase subclass: #SLGameTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLGameTest methodsFor: 'tests' stamp: 'ab 12/20/2018 14:24'!testPlayOneStepOnInexactFinish	| jill jack game |	game := SLGame new		tileNumber: 12;		setLadderFrom: 2 to: 6;		setLadderFrom: 7 to: 9;		setSnakeFrom: 11 to: 5.		jack := SLPlayer new name: 'Jack'.		jill := SLPlayer new name: 'Jill'.		game addPlayer: jill.		game addPlayer: jack.		"jill moves"		game playOneStepWithRoll: 9.		self assert: jill position equals: 10.		self assert: ((game tileAt: 10) includesPlayer: jill).		"jack moves"		game playOneStepWithRoll: 2.		"jill tries to move but in fact stays at her place"		game playOneStepWithRoll: 5.		self assert: jill position equals: 10.		self assert: ((game tileAt: 10) includesPlayer: jill).		self deny: game isOver.! !!SLGameTest methodsFor: 'tests' stamp: 'ab 10/30/2018 23:13'!testPrintingSimpleGameWithPlayers	| game jill jack |	game := SLGame new tileNumber: 12.	jack := SLPlayer new name: 'Jack'.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jill.	game addPlayer: jack.	self		assert: game printString		equals: '[1<Jill><Jack>][2][3][4][5][6][7][8][9][10][11][12]'! !!SLGameTest methodsFor: 'tests' stamp: 'ab 10/23/2018 22:05'!testCheckingSimpleGame	| game |	game := SLGame new tileNumber: 12.	self assert: game tileNumber equals: 12! !!SLGameTest methodsFor: 'tests' stamp: 'ab 11/29/2018 21:52'!testFullGamePrintString	| game |	game := SLGame new tileNumber: 12.	game		setLadderFrom: 2 to: 6;		setLadderFrom: 7 to: 9;		setSnakeFrom: 11 to: 5.	self		assert: game printString		equals: '[1][2->6][3][4][5][6][7->9][8][9][10][5<-11][12]'! !!SLGameTest methodsFor: 'tests' stamp: 'ab 10/27/2018 21:18'!testSeveralPlayersAtStart	| game jill jack |	game := SLGame new tileNumber: 12.	jill := SLPlayer new name: 'Jill'.	jack := SLPlayer new name: 'Jack'.	game addPlayer: jill.	game addPlayer: jack.	self assert: ((game tileAt: 1) includesPlayer: jill).	self assert: ((game tileAt: 1) includesPlayer: jack)! !!SLGameTest methodsFor: 'tests' stamp: 'ab 12/18/2018 21:30'!testPlayerOneStepOnALadder	| jill jack game |	game := SLGame new				tileNumber: 12;				setLadderFrom: 2 to: 6;				setLadderFrom: 7 to: 9;				setSnakeFrom: 11 to: 5.	jack := SLPlayer new name: 'Jack'.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jill.	game addPlayer: jack.	game playOneStepWithRoll: 1.	self assert: jill position equals: 6.	self assert: (game tileAt: 1) players size equals: 1.	self assert: ((game tileAt: 6) includesPlayer: jill)! !!SLGameTest methodsFor: 'tests' stamp: 'ab 12/15/2018 23:29'!testPlayerStepOnASnake	| jill game |	game := SLGame new tileNumber: 12;		setLadderFrom: 2 to: 6;		setLadderFrom: 7 to: 9;		setSnakeFrom: 11 to: 5.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jill.	game movePlayer: jill distance: 10.	self assert: jill position equals: 5.	self assert: (game tileAt: 1) players isEmpty.	self assert: ((game tileAt: 5) includesPlayer: jill)! !!SLGameTest methodsFor: 'tests' stamp: 'ab 11/3/2018 22:12'!testTileOfPlayer	| jill game |	game := SLGame new tileNumber: 12.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jill.	self assert: (game tileOfPlayer: jill) position equals: 1! !!SLGameTest methodsFor: 'tests' stamp: 'ab 11/5/2018 01:22'!testMovePlayerADistance	| jill game |	game := SLGame new tileNumber: 12.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jill.	game movePlayer: jill distance: 4.	self assert: jill position equals: 5.	self assert: (game tileAt: 1) players isEmpty.	self assert: ((game tileAt: 5) includesPlayer: jill)! !!SLGameTest methodsFor: 'tests' stamp: 'ab 12/18/2018 21:08'!testPlayOneStep	| jill jack game |	game := SLGame new tileNumber: 12.	jack := SLPlayer new name: 'Jack'.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jill.	game addPlayer: jack.	self assert: jill position equals: 1.	game playOneStepWithRoll: 3.	self assert: jill position equals: 4.	self assert: (game tileAt: 1) players size equals: 1.	self assert: ((game tileAt: 4) includesPlayer: jill)! !!SLGameTest methodsFor: 'tests' stamp: 'ab 12/18/2018 21:21'!testPlayTwoSteps	| jill jack game |	game := SLGame new tileNumber: 12.	jack := SLPlayer new name: 'Jack'.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jill.	game addPlayer: jack.	game playOneStepWithRoll: 3.	game playOneStepWithRoll: 2.	"nothing changes for jill"	self assert: jill position equals: 4.	self assert: ((game tileAt: 4) includesPlayer: jill).	"now let us verify that jack moved correctly to tile 3"	self assert: (game tileAt: 1) players size equals: 0.	self assert: jack position equals: 3.	self assert: ((game tileAt: 3) includesPlayer: jack)! !!SLGameTest methodsFor: 'tests' stamp: 'ab 12/20/2018 14:19'!testPlayOneStepOnExactFinish	| jill jack game |	game := SLGame new		tileNumber: 12;		setLadderFrom: 2 to: 6;		setLadderFrom: 7 to: 9;		setLadderFrom: 11 to: 5.	jack := SLPlayer new name: 'Jack'.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jill.	game addPlayer: jack.		game playOneStepWithRoll: 11.	"jill lands on the finish tile!!"	self assert: jill position equals: 12.	self assert: (game tileAt: 1) players size equals: 1.	self assert: ((game tileAt: 12) includesPlayer: jill).	self assert: game isOver! !!SLGameTest methodsFor: 'tests' stamp: 'ab 11/3/2018 22:10'!testTileForAtDistance	| jill game |	game := SLGame new tileNumber: 12.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jill.	self assert: (game tileFor: jill atDistance: 4) position equals: 5! !!SLGameTest methodsFor: 'tests' stamp: 'ab 10/27/2018 21:17'!testPlayersAtStart	| game jill |	game := SLGame new tileNumber: 12.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jill.	self assert: ((game tileAt: 1) includesPlayer: jill)! !!SLGameTest methodsFor: 'tests' stamp: 'ab 11/3/2018 22:06'!testPlayerAtStartIsAtPosition1	| game jill |	game := SLGame new tileNumber: 12.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jill.	self assert: jill position equals: 1! !!SLGameTest methodsFor: 'tests' stamp: 'ab 10/27/2018 21:05'!testTileAt	| game |	game := SLGame new tileNumber: 12.	self assert: (game tileAt: 6) printString equals: '[6]'! !!SLGameTest methodsFor: 'tests' stamp: 'ab 12/16/2018 21:23'!testCurrentPlayer	| jack game jill |	game := SLGame new tileNumber: 12.	jack := SLPlayer new name: 'Jack'.	jill := SLPlayer new name: 'Jill'.	game addPlayer: jack; addPlayer: jill.	game turn: 1.	self assert: game currentPlayer equals: jack.	game turn: 2.	self assert: game currentPlayer equals: jill.	game turn: 3.	self assert: game currentPlayer equals: jack.! !!SLGameTest methodsFor: 'tests' stamp: 'ab 12/18/2018 21:03'!testCanMoveToPosition	| game |	game := SLGame new tileNumber: 12.	self assert: (game canMoveToPosition: 8).	self assert: (game canMoveToPosition: 12).	self deny: (game canMoveToPosition: 13)! !!SLGameTest methodsFor: 'tests' stamp: 'ab 10/23/2018 22:09'!testPrintingSimpleGame	| game |	game := SLGame new tileNumber: 12.	self		assert: game printString		equals: '[1][2][3][4][5][6][7][8][9][10][11][12]'	! !!SLGameTest methodsFor: 'tests' stamp: 'ab 12/16/2018 21:40'!testIsOver	| jack game |	game := SLGame new tileNumber: 12.	jack := SLPlayer new name: 'Jack'.	game addPlayer: jack.	self assert: jack position equals: 1.	game movePlayer: jack distance: 11.	self assert: jack position equals: 12.	self assert: game isOver	! !SLActiveTile subclass: #SLLadderTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLLadderTile commentStamp: 'ab 11/8/2018 22:16' prior: 0!Ladder Tile!!SLLadderTile methodsFor: 'printing' stamp: 'ab 11/28/2018 22:18'!printInsideOn: aStream	super printInsideOn: aStream.	aStream << '->'.	targetTile position printOn: aStream		! !Object subclass: #SLPlayer	instanceVariableNames: 'name position'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLPlayer commentStamp: 'ab 10/27/2018 21:08' prior: 0!SLPlayer Class!!SLPlayer methodsFor: 'printing' stamp: 'ab 10/30/2018 23:16'!printOn: aStream	aStream << '<'.	aStream << name.	aStream << '>'.! !!SLPlayer methodsFor: 'accessing' stamp: 'ab 10/27/2018 21:13'!name: aString	name := aString! !!SLPlayer methodsFor: 'accessing' stamp: 'ab 11/3/2018 22:06'!position	^ position! !!SLPlayer methodsFor: 'accessing' stamp: 'ab 11/3/2018 22:06'!position: anInteger	position := anInteger! !SLActiveTile subclass: #SLSnakeTile	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLSnakeTile commentStamp: 'ab 11/8/2018 22:15' prior: 0!Snake Tile!!SLSnakeTile methodsFor: 'printing' stamp: 'ab 11/28/2018 22:19'!printInsideOn: aStream	targetTile position printOn: aStream.	aStream << '<-'.	super printInsideOn: aStream.! !SLAabtractTile subclass: #SLTile	instanceVariableNames: 'players'	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLTile commentStamp: 'ab 10/23/2018 22:09' prior: 0!SLTile Class!!SLTile methodsFor: 'as yet unclassified' stamp: 'ab 12/14/2018 02:27'!releasePlayer: aPlayer	self removePlayer: aPlayer! !!SLTile methodsFor: 'adding' stamp: 'ab 10/27/2018 21:11'!addPlayer: aPlayer	players add: aPlayer! !!SLTile methodsFor: 'accessing' stamp: 'ab 10/27/2018 21:12'!players	^ players! !!SLTile methodsFor: 'testing' stamp: 'ab 10/27/2018 21:17'!includesPlayer: aPlayer	^ players includes: aPlayer! !!SLTile methodsFor: 'visiting' stamp: 'ab 12/14/2018 20:55'!acceptPlayer: aPlayer	super acceptPlayer: aPlayer.	self addPlayer: aPlayer	! !!SLTile methodsFor: 'printing' stamp: 'ab 11/28/2018 22:10'!printInsideOn: aStream	super printInsideOn: aStream.	players do: [ :aPlayer | aPlayer printOn: aStream ]! !!SLTile methodsFor: 'initialization' stamp: 'ab 10/27/2018 21:11'!initialize	players := OrderedCollection new! !!SLTile methodsFor: 'removing' stamp: 'ab 11/5/2018 01:23'!removePlayer: aPlayer	players remove: aPlayer! !TestCase subclass: #SLTileTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SnakesAndLadders'!!SLTileTest methodsFor: 'tests' stamp: 'ab 11/8/2018 22:20'!testPrintingSnake	| tile |	tile := SLSnakeTile new position: 11; to: (SLTile new position: 5).	self assert: tile printString equals: '[5<-11]'! !!SLTileTest methodsFor: 'tests' stamp: 'ab 11/8/2018 22:19'!testPrintingLadder	| tile |	tile := SLLadderTile new position: 2; to: (SLTile new position: 6).	self assert: tile printString equals: '[2->6]'! !!SLTileTest methodsFor: 'tests' stamp: 'ab 10/23/2018 22:13'!testPrinting	| tile |	tile := SLTile new position: 6.	self assert: tile printString equals: '[6]'! !
