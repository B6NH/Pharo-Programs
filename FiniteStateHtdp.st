TestCase subclass: #FSMTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FiniteStateHtdp'!!FSMTests commentStamp: 'ab 2/25/2019 20:06' prior: 0!I am test class for Finite State Machine!!FSMTests methodsFor: 'tests' stamp: 'ab 2/25/2019 20:24'!testSimpleScenario	| aMachine |	aMachine := Machine new initial: 'start';final: 'end'.	aMachine		addTransition:			(Transition new current: 'start';key: 'a';next: 'middle');		addTransition:			(Transition new current: 'middle';key: 'b';next: 'middle');		addTransition:			(Transition new current: 'middle';key: 'c';next: 'middle');		addTransition:			(Transition new current: 'middle';key: 'd' ;next: 'end').		self assert: aMachine initial equals: 'start'.	aMachine pressKey: 'c';pressKey:'s'.	self assert: aMachine initial equals: 'start'.	aMachine pressKey: 'a'.	self assert: aMachine initial equals: 'middle'.	aMachine pressKey: 'd'.	self assert: aMachine initial equals: 'end'.! !Object subclass: #Machine	instanceVariableNames: 'initial transitions final'	classVariableNames: ''	poolDictionaries: ''	category: 'FiniteStateHtdp'!!Machine commentStamp: 'ab 1/8/2019 12:19' prior: 0!I am Finite State Machine!!Machine methodsFor: 'accessing' stamp: 'ab 1/19/2019 00:35'!final	^ final! !!Machine methodsFor: 'accessing' stamp: 'ab 1/8/2019 11:57'!initial: aString	initial := aString! !!Machine methodsFor: 'accessing' stamp: 'ab 1/8/2019 11:58'!final: aString	final := aString! !!Machine methodsFor: 'accessing' stamp: 'ab 2/25/2019 20:10'!initial	^ initial! !!Machine methodsFor: 'as yet unclassified' stamp: 'ab 2/25/2019 20:27'!pressKey: aKey	"do nothing if cant find proper transition, else set new initial value"	|transitionForKey|	transitionForKey := (transitions findForKey: aKey state: initial).	transitionForKey isNil		ifTrue:[]		ifFalse:[ initial := transitionForKey next ]! !!Machine methodsFor: 'adding' stamp: 'ab 1/8/2019 12:01'!addTransition: aTransition	transitions add: aTransition! !!Machine methodsFor: 'initialization' stamp: 'ab 1/13/2019 15:06'!initialize	transitions := Transitions new! !Object subclass: #Transition	instanceVariableNames: 'current key next'	classVariableNames: ''	poolDictionaries: ''	category: 'FiniteStateHtdp'!!Transition commentStamp: 'ab 1/8/2019 12:19' prior: 0!I am Finite State Machine Transition!!Transition methodsFor: 'accessing' stamp: 'ab 1/8/2019 12:02'!next: aState	next := aState! !!Transition methodsFor: 'accessing' stamp: 'ab 1/8/2019 12:02'!current: aState	current := aState! !!Transition methodsFor: 'accessing' stamp: 'ab 1/15/2019 15:30'!key	^ key! !!Transition methodsFor: 'accessing' stamp: 'ab 1/15/2019 15:30'!current	^ current! !!Transition methodsFor: 'accessing' stamp: 'ab 1/15/2019 15:30'!next	^ next! !!Transition methodsFor: 'accessing' stamp: 'ab 1/8/2019 12:02'!key: aKey	key := aKey! !OrderedCollection subclass: #Transitions	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'FiniteStateHtdp'!!Transitions commentStamp: 'ab 1/13/2019 15:06' prior: 0!I am collection of Transitions!!Transitions methodsFor: 'as yet unclassified' stamp: 'ab 2/25/2019 20:23'!findForKey: aKey state: aState	|itemIndex|	itemIndex := (self findFirst:[:transition|(aKey = transition key) & (aState = transition current)]).	^ itemIndex isZero		ifFalse: [ self at: itemIndex ]		ifTrue: [ nil ]! !
