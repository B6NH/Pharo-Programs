Dictionary subclass: #PEnvironment	instanceVariableNames: 'outerEnvironment'	classVariableNames: ''	poolDictionaries: ''	category: 'Phsyche'!!PEnvironment commentStamp: 'ab 5/21/2019 22:00' prior: 0!Environment Class!!PEnvironment methodsFor: 'accessing' stamp: 'ab 5/21/2019 22:03'!at: aKey	| value |	value := self at: aKey ifAabent: [ nil ].	^ value		ifNil: [ outerEnvironment 				ifNil: [ super at: aKey ]				ifNotNil: [ outerEnvironment at: aKey ]			 ]		ifNotNil: [ :v | v ]! !!PEnvironment methodsFor: 'accessing' stamp: 'ab 5/27/2019 03:45'!lookupAt: aKey put: aValue	| found |	found := self at: aKey ifAabent: nil.	found		ifNil: [ outerEnvironment 				ifNotNil: [ outerEnvironment lookupAt: aKey put: aValue ]				ifNil: [ KeyNotFound signal: aKey , ' not found in the environment' ] ]		ifNotNil: [ self at: aKey put: aValue ]! !!PEnvironment methodsFor: 'accessing' stamp: 'ab 5/21/2019 22:00'!outerEnvironment: anEnvironment	outerEnvironment := anEnvironment! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PEnvironment class	instanceVariableNames: ''!!PEnvironment class methodsFor: 'instance creation' stamp: 'ab 5/23/2019 22:46'!newFromKeys: keys andValues: values	| dict |	dict := self new.	keys with: values do: [ :k :v | dict at: k put: v ].	^ dict! !TestCase subclass: #PEnvironmentTest	instanceVariableNames: 'outer inner'	classVariableNames: ''	poolDictionaries: ''	category: 'Phsyche'!!PEnvironmentTest commentStamp: 'ab 5/21/2019 21:54' prior: 0!Environment Test Class!!PEnvironmentTest methodsFor: 'initialization' stamp: 'ab 5/21/2019 21:55'!setUp	outer := PEnvironment new.	inner := PEnvironment new.	inner outerEnvironment: outer! !!PEnvironmentTest methodsFor: 'tests' stamp: 'ab 5/21/2019 21:57'!testLookingOuterFromInner	outer at: #dad put: 'donald'.	inner at: #son put: 'riri'.	self assert: (inner at: #dad) equals: 'donald'! !!PEnvironmentTest methodsFor: 'tests' stamp: 'ab 5/27/2019 03:36'!testSetLookup	outer at: #dad put: 'donald'.	inner at: #son put: 'riri'.	self assert: (inner at: #dad) = 'donald'.	inner lookupAt: #dad put: 'picsou'.	self assert: (outer at: #dad) = 'picsou'.	self assert: (inner at: #dad) = 'picsou'.	self deny: (inner keys includes: #dad)! !!PEnvironmentTest methodsFor: 'tests' stamp: 'ab 5/21/2019 21:56'!testLookupAtRightLevel	outer at: #dad put: 'donald'.	self assert: (outer at: #dad) equals: 'donald'.	inner at: #son put: 'riri'.	self assert: (inner at: #son) equals: 'riri'! !!PEnvironmentTest methodsFor: 'tests' stamp: 'ab 5/21/2019 21:58'!testLookupInFails	outer at: #dad put: 'donald'.	inner at: #son put: 'riri'.	self should: [ outer at: #nodad ] raise: KeyNotFound.	self should: [ outer at: #noson ] raise: KeyNotFound.	self should: [ inner at: #nodad ] raise: KeyNotFound.! !!PEnvironmentTest methodsFor: 'tests' stamp: 'ab 5/27/2019 03:33'!testSetAtRightLevel	outer at: #dad put: 'donald'.	inner at: #son put: 'riri'.	self assert: (inner at: #son) = 'riri'.	inner lookupAt: #son put: 'fifi'.		self assert: (outer at: #dad) = 'donald'.	outer lookupAt: #dad put: 'piscou'.	self assert: (outer at: #dad) = 'piscou'.! !Object subclass: #PFunction	instanceVariableNames: 'parameters body environment'	classVariableNames: ''	poolDictionaries: ''	category: 'Phsyche'!!PFunction commentStamp: 'ab 5/21/2019 22:18' prior: 0!Function Class!!PFunction methodsFor: 'initialization' stamp: 'ab 5/23/2019 22:47'!setEnvironmentForParameters: values in: outerEnvironment	| applicationEnvironment |	applicationEnvironment := PEnvironment newFromKeys: self parameters andValues: values.	applicationEnvironment outerEnvironment: outerEnvironment.	^ applicationEnvironment! !!PFunction methodsFor: 'accessing' stamp: 'ab 5/21/2019 22:22'!body: functionBody	body := functionBody! !!PFunction methodsFor: 'accessing' stamp: 'ab 5/21/2019 22:22'!parameters	^ parameters! !!PFunction methodsFor: 'accessing' stamp: 'ab 5/21/2019 22:21'!parameters: functionParams	parameters := functionParams! !!PFunction methodsFor: 'accessing' stamp: 'ab 5/27/2019 03:13'!environment	^ environment! !!PFunction methodsFor: 'accessing' stamp: 'ab 5/21/2019 22:22'!body	^ body! !!PFunction methodsFor: 'accessing' stamp: 'ab 5/27/2019 03:12'!environment: anEnvironment	environment := anEnvironment! !Object subclass: #Phsyche	instanceVariableNames: 'environment primitives'	classVariableNames: ''	poolDictionaries: ''	category: 'Phsyche'!!Phsyche commentStamp: 'ab 5/14/2019 22:23' prior: 0!Phsyche Interpreter Class!!Phsyche methodsFor: 'testing' stamp: 'ab 5/15/2019 21:38'!isEqualBinding	^ #equal -> [ :e :v | e = v ]! !!Phsyche methodsFor: 'testing' stamp: 'ab 5/15/2019 21:52'!isNullBinding	^ #isNull -> [ :l | l = #() ]! !!Phsyche methodsFor: 'testing' stamp: 'ab 5/15/2019 21:44'!isNotBinding	^ #not -> [ :a | a not ]! !!Phsyche methodsFor: 'initialization' stamp: 'ab 5/15/2019 21:36'!initializeEnvBindings	(self class selectors select: [ :each | each endsWith: 'Binding'])		do: [ :s |			| binding |			binding := self perform: s.			primitives add: binding key.			environment at: binding key put: binding value			 ]! !!Phsyche methodsFor: 'initialization' stamp: 'ab 5/27/2019 03:51'!initialize	super initialize.	environment := PEnvironment new.	primitives := OrderedCollection new.	self initializeEnvBindings! !!Phsyche methodsFor: 'parsing' stamp: 'ab 5/14/2019 22:25'!parse: aProgramString	aProgramString ifEmpty: [ ^ #() ].	^ (Scanner new scanTokens: aProgramString) first! !!Phsyche methodsFor: 'parsing' stamp: 'ab 5/14/2019 22:31'!parseAndEval: anExpression	^ self eval: (self parse: anExpression)! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/27/2019 03:49'!evalSetSpecialForm: expression in: anEnvironment	anEnvironment		lookupAt: expression second		put: (self eval: expression third in: anEnvironment).		^ #undefined! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 02:49'!eval: expression	^ self eval: expression in: environment! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:30'!evalPrimitive: exp in: anEnvironment	^ (anEnvironment at: exp first)		valueWithPossibleArgs: (exp allButFirst collect: [ :e | self eval: e in: anEnvironment])! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:41'!divisionBinding	^ #/ -> [ :e :v | (e / v) asFloat ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/27/2019 13:56'!evalApplicativeOrder: expression in: anEnvironment	| proc newEnv |	proc := self eval: expression first in: anEnvironment.	newEnv  := proc		setEnvironmentForParameters: (expression allButFirst collect: [ :e |			self eval: e in: anEnvironment ])		in: proc environment.	^ self eval: proc body in: newEnv! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:51'!consBinding	^ #cons -> [ :e :l | {e} , l ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/27/2019 13:37'!evalBeginSpecialForm: expression in: anEnvironment	| res |	expression allButFirst		do: [ :each | res := self eval: each in: anEnvironment ].	^ res! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:39'!greaterBinding	^ #> -> [ :e :v | e > v ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:39'!greaterOrEqualBinding	^ #>= -> [ :e :v | e >= v ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:25'!multBinding	^ #* -> [ :e :v | e * v ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/27/2019 13:56'!evalLambdaSpecialForm: expression in: anEnvironment	^ PFunction new		parameters: expression second;		body: expression third;		environment: anEnvironment! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:25'!plusBinding	^ #+ -> [ :e :v | e + v ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:40'!smallerBinding	^ #< -> [ :e :v | e < v ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 22:01'!evalIfSpecialForm: expression in: anEnvironment	^ (self eval: expression second in: anEnvironment)		ifTrue: [ self eval: expression third in: anEnvironment ]		ifFalse: [ self eval: expression fourth in: anEnvironment ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/27/2019 13:36'!eval: expression in: anEnvironment	expression = #()		ifTrue: [ ^ expression ].	expression isSymbol		ifTrue: [ ^ anEnvironment at: expression ].	expression isArray		ifFalse: [ ^ expression ]		ifTrue: [ | first |			first := expression first.			(primitives includes: first)				ifTrue: [ ^ self evalPrimitive: expression in: anEnvironment  ]				ifFalse: [ 					first = #define						ifTrue: [ ^ self evalDefineSpecialForm: expression in: anEnvironment  ].					first = #set						ifTrue: [ ^ self evalSetSpecialForm: expression in: anEnvironment ].					first = #lambda						ifTrue: [ ^ self evalLambdaSpecialForm: expression in: anEnvironment ].					first = #begin						ifTrue: [ ^ self evalBeginSpecialForm: expression in: anEnvironment ].					first = #if						ifTrue: [ ^ self evalIfSpecialForm: expression in: anEnvironment  ].					first = #quote						ifTrue: [ ^ expression second ]						ifFalse: [ ^ self evalApplicativeOrder: expression in: anEnvironment ]					]			 ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 02:54'!evalDefineSpecialForm: expression in: anEnvironment	anEnvironment		at: expression second		put: (self eval: expression third in: anEnvironment ).	^ #undefined! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:40'!smallerOrEqualBinding	^ #<= -> [ :e :v | e <= v ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:40'!minusBinding	^ #- -> [ :e :v | e - v ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:50'!cdrBinding	^ #cdr -> [ :l | l allButFirst ]! !!Phsyche methodsFor: 'as yet unclassified' stamp: 'ab 5/15/2019 21:50'!carBinding	^ #car -> [ :l | l first ]! !TestCase subclass: #PhsycheTest	instanceVariableNames: 'ph'	classVariableNames: ''	poolDictionaries: ''	category: 'Phsyche'!!PhsycheTest commentStamp: 'ab 5/14/2019 22:15' prior: 0!Phsyche Test Class!!PhsycheTest methodsFor: 'initialization' stamp: 'ab 5/14/2019 22:15'!setUp	ph := Phsyche new! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/14/2019 22:18'!testParseLambda	self		assert: (ph parse: '(define squared (lambda(x)(* x x)))' )		equals: #(#define #squared #(#lambda #(#x) #(* x x)))! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 02:56'!testEvalExpression2	ph parseAndEval: '(define pi 3.14)'.	ph parseAndEval: '(define pi2 pi)'.	ph parseAndEval: '(define pi 6.28)'.	self assert: (ph parseAndEval: 'pi2') equals: 3.14! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 22:00'!testEvalIfNoSpurious	self assert: (ph eval: (ph parse: '(if true 4 (/ 5 0))')) equals: 4.	self assert: (ph eval: (ph parse: '(if false (/ 5 0) 5)')) equals: 5! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 21:43'!testNot	self assert: (ph parseAndEval: '(not false)').	self deny: (ph parseAndEval: '(not true)')! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/14/2019 22:30'!testEvalBoolean	self assert: (ph parseAndEval: 'true') equals: true.	self assert: (ph parseAndEval: 'false') equals: false.! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/14/2019 22:20'!testParseSymbol	self		assert: (ph parse: 'r')		equals: #r	! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/27/2019 03:08'!testSimpleClosure	| res |	res := ph eval: (ph parse: '(((lambda(x)(lambda(y)(+ x y)))3)7)').	self assert: res equals: 10! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 02:47'!testDefineExpression	ph parseAndEval: '(define pi 3.14)'.	self		assert: (ph parseAndEval: 'pi')		equals: 3.14	! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 03:02'!testEvalQuote	self		assert: (ph parseAndEval: '(quote(* x x))')		equals: #(#* #x #x).	self		assert: (ph parseAndEval: '(quote(quote(* x x)))')		equals: #(quote #(#* #x #x))	! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/14/2019 22:31'!testEvalNumber	self assert: (ph parseAndEval: '12') equals: 12.	self assert: (ph parseAndEval: '3.14') equals: 3.14! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/14/2019 22:29'!testEvalEmptyList	self assert: (ph parseAndEval: '()') equals: #()! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/27/2019 13:35'!testEvalBeginSet	self assert: (ph parseAndEval: '(begin(define x 1)(set x 2)x)') equals: 2! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 21:46'!testEvalListExpression	self assert: (ph parseAndEval: '(cons(quote a)())') equals: #(a)! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/14/2019 22:22'!testParseIsNull	self		assert: (ph parse: '(isNull(cons(quote a) #()))')		equals: #(#isNull #(#cons #(#quote #a) #())).	self		assert: (ph parse: '(isNull (cons(quote a)()))')		equals: #(#isNull #(#cons #(#quote #a) #()))! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 21:22'!testEvalExpression	self assert: (ph parseAndEval: '(* 3 8)') equals: 24! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 21:47'!testEvalCarExpressionEvaluatesItsArgument	self		assert: (ph parseAndEval: '(car(cons(quote a)(cons(quote b)())))')		equals: #a! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/27/2019 03:47'!testEvalSimpleSet	self assert: (ph parseAndEval: '(define x2 21') equals: #undefined.	self assert: (ph parseAndEval: '(set x2 22)') equals: #undefined.	self assert: (ph parseAndEval: 'x2') equals: 22.! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 21:24'!testEvalMoreComplexExpression	self assert: (ph parseAndEval: '(*(+ 2 3)8)') equals: 40.	self assert: (ph parseAndEval: '(* 8 (+ 2 3))') equals: 40! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/27/2019 03:59'!testSimpleClosureIntrospection	| proc |	ph parseAndEval: '(define fy3((lambda(x)(lambda(y)x))3))'.	proc := ph parseAndEval: '#fy3'. 	self assert: proc parameters equals: #(y).	self assert: (proc environment at: #x) equals: 3! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 21:57'!testEvalIf	self assert: (ph parseAndEval: '(if true 4 5)') equals: 4.	self assert: (ph parseAndEval: '(if false 4 5)') equals: 5! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/23/2019 22:34'!testLambdaFunctionExecution	self assert: (ph parseAndEval: '((lambda(x)(* x x))3)') equals: 9! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 21:42'!testDivision	self should: [ ph parseAndEval: '(/ 5 0)' ] raise: ZeroDivide! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 21:50'!testIsNull	self assert: (ph parseAndEval: '(isNull #())').	self assert: (ph parseAndEval: '(isNull(quote()))').	self deny: (ph parseAndEval: '(isNull(cons(quote a)()))')! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/15/2019 21:48'!testEvalCdrExpressionEvaluatesItsArgument	self		assert: (ph parseAndEval: '(cdr(quote(quote a)))')		equals: #(a)	! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/14/2019 22:19'!testParseFloat	self		assert: (ph parse: '12.33')		equals: 12.33! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/14/2019 22:19'!testParseEmptyList	self assert: (ph parse: '()') equals: #()! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/23/2019 22:35'!testFunctionExecution	ph parseAndEval: '(define squared(lambda(x)(* x x)))'.	self assert: (ph parseAndEval: '(squared 3)') equals: 9! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/27/2019 13:34'!testEvalBegin	self assert: (ph parseAndEval: '(begin 1 2 3)') equals: 3! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/27/2019 13:42'!testEvalSetAtCorrectLevel	| proc |	ph parseAndEval: '(define fy3		((lambda(x)			(lambda(y)				(begin(set x(+ x 2))						(+ x y))))3))'.	proc := ph eval:  #fy3.	self assert: (ph parseAndEval: '(fy3 5)') equals: 10! !!PhsycheTest methodsFor: 'tests' stamp: 'ab 5/21/2019 22:17'!testFunctionDefinition	| proc |	ph parseAndEval: '(define squared(lambda(x)(* x x)))'.	proc := ph parseAndEval: #squared.	self assert: proc parameters equals: #(#x).	self assert: proc body equals: #(#* #x #x)! !
